'''
Primary contents: miscellaneous convenience functions for calculating properties of continuous and discrete
	probability distributions, and for generating random variates from some distributions.
	E.g., crv_var_exp calculates the variance and expectation for an arbitrary probability distribution.
	correlation and covariance calculate the correlation and covariance, respectively, between two data sets.
	pnorm calculates the normal CDF.
	These functions use my implementation of numerical integration, which sucks compared to 
	Scipy.integrate.quad.
The corresponding functions in Scipy and numpy, where they exist, are undoubtedly better in 
	every meaningful way.
That said, my rgeom and rbinom functions are actually somewhat faster than Scipy.geom(p).rvs(n) and
	Scipy.binom(p).rvs(n) when p is fairly high (say, greater than 1/3) and n is small (say less than 20).
	In any other regime, my functions are much slower.
	
Also contains my implementations of bisection search, both for determining whether a value is in a list (bindex)
	and for quickly finding the closest value in a list (closebin). Because one can never have too many 
	ways to do bisection search.
	
Contains "sample", a function for biased and unbiased sampling with replacement, which is the foundation
	for my functions for generating random variates.

Contains "frac", a convenience class I made that implements fractions that can be added, multiplied,
	divided, etc., just like normal ints and floats. frac is used to enable the calculation of binomial
	probabilities for very large values of nCk, because multiplying a float by a huge number generated by
	math.factorial leads to overflow errors.

Contains "polynom", a convenience class that implements polynomials.

For those who are wondering, yes, I DID find out about the numpy.poly1d convenience class 
	(which is better than my polynom, FYI) and the built-in "fractions" module,
	but only AFTER I made those implementations.
'''
from scipy import integrate,stats
import math,random,numpy as np
from math import e,pi

def bindex(n, List,asc=True,get_index=True):
	"""n: a string or numeric.
	List: a SORTED list or tuple containing only strings or numerics
	asc: True if the iterable is sorted ascending, false if descending.
	get_index: If True, returns the index where n was found in List, else None if it's not there.
	If not get_index, bindex returns True if n is in the List, else False.
	"""
	low=0
	high=len(List)
	Indx=(high+low)//2
	while List[Indx]!=n: #do binary search for the index of the closest entry.
		if Indx>=len(List)-1 or Indx==0 or high-low<=1:
			break
		elif (List[Indx] > n and asc) or (List[Indx] < n and not asc):
			high=Indx
			Indx=(high+low)//2
		elif (List[Indx] < n and asc) or (List[Indx] > n and not asc):
			low=Indx
			Indx=(high+low)//2
		assert not (str(List[Indx])=='nan' and type(List[Indx])==float), 'Cannot do binary search on a list with float(\'nan\') because it does not support comparisons.'
	
	for i in [Indx-1,Indx,Indx+1]:
		if i<0 or i>=len(List):
			continue
		assert not (str(List[i])=='nan' and type(List[i])==float), 'Cannot do binary search on a list with float(\'nan\') because it does not support comparisons.'
		if List[i]==n:
			if get_index:
				return i
			else:
				return True
	if not get_index:
		return False
	return None

def closebin(n,List,asc=True,epsilon=0,get_index=False): #also aliased as binclose
	'''n: a number
List: a SORTED iterable containing only numbers
Returns: the closest entry in List to n, or the first entry found within epsilon.
asc: True if List are sorted ascending, False otherwise.
epsilon: The maximum distance from n at which the search will terminate.
If epsilon is 0, the search will continue until it reaches the final branch
of the binary search tree.
get_index: If true, return a tuple (closest number, index of closest number)
	'''
	low=0
	high=len(List)
	Indx=(high+low)//2
	while abs(List[Indx]-n)>epsilon: #do binary search for the index
					#of the closest entry.
		if Indx>=len(List)-1 or Indx==0 or high-low<=1:
			break
		elif (List[Indx]-n > epsilon and asc) or (List[Indx]-n < -epsilon and not asc):
			high=Indx
			Indx=(high+low)//2
		elif (List[Indx]-n < -epsilon and asc) or (List[Indx]-n > epsilon and not asc):
			low=Indx
			Indx=(high+low)//2
		assert not (str(List[Indx])=='nan' and type(List[Indx])==float), 'Cannot do binary search on a list with float(\'nan\') because it does not support comparisons.'
	#Get as many of Indx, Indx-1, and Indx+1 as are in the list.
	near_inds=[]
	for x in [Indx-1,Indx,Indx+1]:
		if x >=0 and x<len(List):
			assert not (str(List[x])=='nan' and type(List[x])==float), 'Cannot do binary search on a list with float(\'nan\') because it does not support comparisons.'
			near_inds.append(x)
	#sort the indices of the 1-3 closest entries by their distance from n.
	near_inds = sorted(near_inds, key=lambda x: abs(List[x]-n))
	if not get_index:
		return List[near_inds[0]] #get closest entry
	else:
		return List[near_inds[0]],near_inds[0] #get closest entry and its index

exp_pdf = lambda x, l: l * e**(-l*x)
exp_cdf = lambda x,l: 1-e**(-l*x)
def covariance(x,y):
	if type(x)!=np.ndarray:
		x=np.array(x)
	if type(y)!=np.ndarray:
		y=np.array(y)
	return np.mean(x*y)-np.mean(x)*np.mean(y)

def correlation(x,y):
	return cov(x,y)/np.std(x)/np.std(y)

def qexp(L,q):
	'''Returns the q quantile of the exponential distribution cdf'''
	return math.log(1/(1-q))*1/L
def ppois(lamtau,k):
	'''Use scipy's stats.poisson(lamtau).pmf(k) instead of this.
lamtau: lambda*tau, the rate of events occurring per unit time * the number of time units
	k: the number of events
Remember: the Poisson distribution is a sum of INDEPENDENT exponential RVs.'''
	out=np.e**-(lamtau)
	for i in range(1,k+1):
		out*=lamtau/i 
		#The PMF is (lambda*tau)**k * e**(-lambda*tau) / k!,
		#but if you explicitly calculate lambda*tau ** k and k!, you will frequently
		#get OverflowErrors. This loop is a way around that.
	return out

def sample(pop,n,replace=True,weights=None):
	'''Get a sample of size n from the iterable pop.
weights: a vector of same length as pop, containing weights to assign to
	each item in pop. By default, all items have equal weight.
If replace is False, sampling is done without replacement.
NOTE: At present, WEIGHTED SAMPLING WITHOUT REPLACEMENT IS NOT IMPLEMENTED.
So you can do weighted sampling with replacement, and unweighted sampling with or without replacement.
	'''
	if weights is not None and not replace:
		raise NotImplementedError
	if weights is None:
		if replace: #unbiased sampling with replacement
			return np.array([random.choice(pop) for x in range(n)])
		else: #unbiased sampling without replacement
			return np.array(random.sample(pop,n))
	else: #the entries have weighted probabability.
		choices=np.random.random(n)
		cumweight=np.cumsum(weights)/sum(weights)
		#print(cumweight)
		output=[]
		if replace:
			for i in range(n):
				ind=closebin(choices[i],cumweight,get_index=True)[1]
				closest=cumweight[ind]
				#print("\n"+str(choices[i])+", "+str(ind),end=", ")
				if ind==len(cumweight)-1:
					output.append(pop[-1])
					#print(pop[-1])
				elif closest >= choices[i]:
					output.append(pop[ind])
					#print(pop[ind])
				elif closest < choices[i]:
					output.append(pop[ind+1])
					#print(pop[ind+1])
		return np.array(output)
	
def derlang(lam,k,t):
	'''lam: A positive float, the rate parameter of the exponential distribution.
t: time, a non-negative float.
k: The number of arrivals by time t. A non-negative int.
The PDF of the Erlang distribution, (lam*t)**(k-1) * e**(-lam*t) / (k-1)!
The Erlang PDF with params lam and k can be integrated from 0 to x to find the 
	probability that a Poisson RV with parameter lam 
	will have had k arrivals by time x.'''
	out=np.e**(-lam*t)
	for i in range(1,k):
		out *= lam*t / i
	return out

def rpois(lamtau,n):
	'''Use scipy's stats.poisson(lamtau).rvs(n) instead of this.
Generates a list of n random integers generated from the Poisson PMF
with parameter lamtau: (lamtau)**k * e**(-lamtau) / k!, where k is an integer
Note: lamtau is just a combination of lambda*tau, where lambda is the rate parameter
	that defines a Poisson distribution and tau is the time interval.'''
	p=ppois(lamtau,0)
	ks,ps,i = [0],[p],0
	while p<1e-20: #for large lamtau, you need to go up to k>>0 before
				   #the Poisson PMF has meaninful density.
		i+=1
		p=ppois(lamtau,i)
	while p > 1e-20:
		i+=1
		ks.append(i)
		p=ppois(lamtau,i)
		ps.append(p)
	return sample(ks,n,True,ps)

def Rsquared(data,fit):
	'''data, fit: equal-length iterables of numbers
The technical term for R^2 is the "coefficient of determination."
It is, roughly speaking, the proportion of variability in the data
	that is explained by the fit.
For a best fit line, R^2 must be in (0,1].'''
	var_of_fit = np.mean([(data[i] - fit[i])**2 for i in range(len(fit))])
	var_from_mean = np.var(data)
	return 1 - var_of_fit/var_from_mean

def randexp(L,n):
	'''Generate an array of n random values from an exponential
probability distribution with parameter L, that is with f_X(x)=L*e**(-L*x)
Use sciy's stats.expon(L).rvs(n) instead of this.'''
	return np.array([qexp(L,random.random()) for x in range(n)])

def geom(p,n): 
	'''Probability that a coin with P(Heads) = p does not land heads until the nth flip.'''
	return p*(1-p)**(n-1)

def rgeom(p,n):
	'''Generates n random variates from the geometric distribution with parameter p.
For very low values of p (say, 1/40), it is better to use scipy.stats.geom(p).rvs(n).
But for fairly high values of p, like 1/2, this seems to be faster than scipy.stats.geom(p).rvs()
for generating one value.
For large n, scipy.stats.geom(p).rvs(n) will always be significantly faster at generating a large array.'''
	cutoff=round(math.log(5e-18,1-p))
	probs=[]
	for i in range(1,cutoff):
		probs.append(geom(p,i))
	return sample(list(range(1,cutoff)),n,True,probs)

"""def hypergeom2(pop_size,n_items,total_draws,item_draws):
	'''pop_size: A positive integer, the total number of items
n_items: The number of a specific type of item, <= pop_size.
total_draws: The number of draws you make WITHOUT REPLACEMENT
	from the population.
item_draws: The number of that specific item that you draw.
Returns: The probability that you will draw item_draws of the item of
	interest when making total_draws draws w/o replacement.'''
	assert n_items<=pop_size, 'n_items must be <= pop_size.'
	assert item_draws<=total_draws, 'item_draws must be <=total_draws'
	return choose(n_items,item_draws)*choose(pop_size-n_items,total_draws-item_draws)/choose(pop_size,total_draws)"""

def hypergeom(type_totals,draws_of_type):
	'''type_totals: An iterable, the total number of items of each type
draws_of_type: An iterable of same len as type_totals, number of draws of
	each type
Returns: The probability that you will get exactly that many draws of each
	type in sum(draws_of_type) draws without replacement from a
	population initially described by type_totals'''
	out=1
	for i in range(len(type_totals)):
		out*=choose(type_totals[i],draws_of_type[i])
	return out/choose(sum(type_totals),sum(draws_of_type))

def Integrate(func,start,end,num_points=1e5):
	'''Use scipy's integrate.quad instead of this, or the Integral module I ripped from https://github.com/KRBM/numeric_integration/commits?author=KRBM.
	func: a function.
	start, end: floats representing the bounds of integration. start can be smaller than end.
	num_points: The number of points at which the function is computed.
	Returns: the sum of the function at all num_points points between start and end,
	divided by num_points and multiplied by (end-start). Approximates the integral for large 
	num_points.
	'''
	pts=np.linspace(start,end,int(num_points))
	return sum(func(pts))/num_points*(end-start)

def deriv(func, x,epsilon=1e-8):
	'''Calculate the approximate derivative of func at x.
epsilon: The difference between x and the two other points at which the function 
	is also calculated. So if x=1000 and epsilon=1e-8, this function will return the
	average of (func(1000+1e-8)-func(1000))/1e-8 and (func(1000)-func(1000-1e-8))/1e-8
	'''
	points_around=2
	dx=0
	for i in range(1,1+points_around):
		try:
			if i%2==0:
				above=x+epsilon*i
				dx+=(func(above)-func(x))/(above-x)
			elif i%2==1:
				below=x-epsilon*i
				dx+=(func(x)-func(below))/(x-below)
		except ZeroDivisionError:
			return deriv(func,x,epsilon*2) #keep increasing epsilon until it works
	return dx/points_around

def perm(n,k):
	'''n,k ints.
	Return the number of ways you can choose k out of n items, when order
	of choice DOES matter.'''
	assert k>=0 and k<=n, "Cannot calculate nPk or nCk when k>n or k<0."
	if int(k)!=k or int(n)!=n:
		print("Cannot calculate nPk or nCk for non-integer n and k. Casting n and k to integers.")
		k,n=int(k),int(n)
	rst=1
	for i in range(n-k+1,n+1):
		rst*=i
	return rst

def choose(n,k):
	'''n,k ints.
	Return the number of ways you can choose k out of n items, when order
	of choice doesn't matter.'''
	if k==0:
		return 1 
	if int(k)!=k or int(n)!=n:
		print("Cannot calculate nPk or nCk for non-integer n and k. Casting n and k to integers.")
		k,n=int(k),int(n)
	if k>n//2:
		return choose(n,n-k) #take advantage of the symmetry of nCk about n/2.
	#use fractions to ensure no floating point error and less risk of overflow.
	return int(prod([frac(n-i,k-i) for i in range(k)])) 

def binom(n,p,k):
	'''Returns the probability that an event with probability p will happen k
	times in n independent trials.'''
	return choose(n,k) * p**k * (1-p)**(n-k)
	
def pascal(n,p,k):
	'''Returns the probability that the kth arrival of a Bernoulli process
with parameter p occurs exactly on the nth trial.
Compare to binom(n,p,k), which calculates the probability that
the kth arrival of a Bernoulli process with parameter p occurs on or before
the nth trial.'''
	return binom(n-1,p,k-1)*p

def binom_cdf(n,p,k1,k2=None):
	if k2 is None:
		k2=n
	return sum([binom(n,p,k) for k in range(k1,k2+1)])
	
def rbinom(n,p,n_rands):
	'''Generate an np.array of n_rands random variates from the 
binomial distribution with parameters n and p.
This is slower than pr.binom(n,p).rvs(n_rands) for large n_rands, 
	but faster when n_rands is less than 20 or so, but only if n is small.
If n is large, this will ALWAYS be slower than pr.binom(n,p).rvs(n_rands)'''
	lookup=[binom(n,p,k) for k in range(n)]
	return sample(list(range(n)),n_rands,True,lookup)

def durv_var_exp(values):
	'''values: a list, tuple, or np.array of numeric values.
Returns: a tuple of expectation value and variance of a discrete uniform
random variable that takes on the values given,'''
	exp=sum(values)/len(values)
	var = sum([x**2 for x in values])/len(values) - exp**2
	return exp, var
	
def crv_var_exp(pdf_func,start,end,is_normalized=True,num_points=1.5e5):
	'''pdf_func: the probability distribution function of a continuous random variable.
start,end: the limits of integration (usually the region over which the PDF is defined).
Returns: a tuple of the expectation value and the variance of the CRV.
is_normalized: Indicates if the pdf_func is already normalized. If not, finds the normalizing
	constant before calculating the expected value and variance.
num_points: The number of points at which to calculate the integral. Usually 1.5e5 is		
	sufficient.
	'''
	if not is_normalized:
		norm=1/Integrate(pdf_func,start,end)
		pdf_fun=lambda x: pdf_func(x)*norm
	else:
		pdf_fun=pdf_func
	exp=Integrate(lambda i: i*pdf_fun(i),start,end,num_points)
	var=Integrate(lambda i: i**2*pdf_fun(i),start,end,num_points)-exp**2
	return exp,var

def find_normalizing_constant(pdf_func,start,end,num_points=1.5e5):
	return 1/Integrate(pdf_func,start,end)

def curv(x):
	'''Use this function as the pdf_func for continuous uniform random variables.'''
	if type(x) in [int,float]:
		return 1
	else:
		return np.array([1 for i in x])

def dnorm(x,mu=0,var=1):
	const=1/(2*np.pi*var)**0.5
	quad=(x-mu)**2/(2*var)
	return const*np.e**-quad
	
def pnorm(x,mu=0,sd=1,num_points=120000):
	'''Use scipy's stats.norm(mu,sd).pdf(x) instead of this.
	Finds the CDF of the normal distribution by computing the (approximate) integral
	of the normal PDF from -12 to x. Sums at 120,000 points by default.'''
	z=(x-mu)/sd
	nz=-abs(z)
	p=Integrate(lambda i:dnorm(i),-12,nz,num_points)
	if x>mu:
		return 1-p
	else:
		return p

def qnorm(q,mu=0,sd=1,epsilon=1e-5):
	'''Use scipy's stats.norm(mu,sd).ppf(x) instead of this.
Returns the value of x at which the CDF of a normal with mean=mu and
variance=sd**2 is within epsilon of q. Thus, for example, if you search
qnorm(0.5,m,v), you'll get m, because the mean is the 50th percentile, and if you
search qnorm(0.975,2,3), you'll get about 8 because the 97.5th percentile is two
standard deviations above the mean.
Note: This is VERY SLOW. A lookup table would probably make it much faster.
	'''
	start,end = mu-sd*12, mu+sd*12
	low,high=start,end
	mid=mu
	guess=pnorm(mid,mu,sd)
	while True:
		if abs(mid-start)<=epsilon or abs(mid-end)<=epsilon or abs(q-guess)<=epsilon:
			return mid
		if guess-q>epsilon:
			high=mid
		elif guess-q < -epsilon:
			low=mid
		mid=(low+high)/2
		guess=pnorm(mid,mu,sd)

def newtraph(func,x,epsilon=1e-7):
	loops=0
	while abs(func(x))>epsilon:
		loops+=1
		fun=func(x)
		try:
			der=deriv(func,x,epsilon=1e-9)
		except ZeroDivisionError:
			return x
		x=x-fun/der
		if loops>=9000:
			print("Newton-Raphson method failed to converge in 9,000 iterations.")
			print("This function probably has no real roots.")
			return None
	return x,loops

def convex(func,start,end,points=int(5e4)):
	'''Determines if the function func is convex on the interval (start,end).
That means that that the first-order Taylor approximation of the function is less than the
function itself everywhere on that interval.
If the function has a second derivative, this is equivalent to the statement
that the second derivative is non-negative everywhere on (start,end).
Note that this function is VERY SLOW for points=1.5e5.
	'''
	x=np.linspace(start,end,points)
	if type(func)==np.poly1d:
		der2=func.deriv().deriv()
		#Get the unique zeroes of the second derivative-
		#by default Python may list the same zero multiple times.
		d2zeros=list(dict(Counter(der2.roots)).keys())
		roots_on_range=0
		for root in d2zeros:
			if root>=start and root<=end:
				roots_on_range+=1
		if roots_on_range==0:
			#The second derivative never crosses the x axis
			#on the range, so whatever sign the second derivative
			#has at the start it must also have throughout the
			#range
			return der2(start)>=0
		elif roots_on_range==1:
			#if the second derivative is non-negative at both the
			#start and the end in the 1-root case, we know that
			#the function is convex on the range.
			return der2(start)>=0 and der2(end)>=0
		elif roots_on_range==2:
			#in this case, the only way for the function to be
			#convex is if the 2nd derivative is 0 at exactly the
			#start or end and is non-negative elsewhere.
			if d2zeros[0]==start and d2zeros[0]==end:
				return der2((start+end)/2) >= 0
			else:
				return False
		else:
			#3 or more roots on range means the the 2nd derivative
			#must be negative somewhere on the range.
			return False
	is_convex=True
	for i in range(1,points-1):
		der=pr.deriv(func,x[i])
		if der>func(x[i-1]) or der>func(x[i+1]):
			is_convex=False
			break
	return is_convex

def prod(iterable,start=0,end=None):
	'''Return product of all elements in the iterable[start:end]. Analogous to built-in sum function.'''
	if len(iterable)==0:
		return 0
	if not end:
		end=len(iterable)+1
	out=1
	for i in iterable[start:end]:
		out*=i
	return out

class frac(object): #this is aliased as f, below.
	'''numer: an int, tuple of ints, or a string of the form "int/int".
	denom: an int, if numer is an int.
	returns: a fraction object with some convenient methods
	Can be added, multiplied or raised to powers just like an int or float'''
	def __init__(this,numer,denom=None):
		if type(numer)==frac:
			numer,denom=numer.n,numer.d
		if type(numer) in [tuple,list]:
			numer,denom=numer[0],numer[1]
		if type(numer)==str:
			numer,denom=tuple(numer.split('/'))
		if int(denom)==0:
			raise ZeroDivisionError
		this.n=int(numer)
		this.d=int(denom)
	def __getitem__(this,i): 
		#this method lets you use the obj[i:j] shortcut to access attributes i through j-1
		#of an object.
		return (this.n,this.d)[i]
	def __eq__(this,other): #This method defines how == is used to compare things
		return abs(float(this)-float(other))<min(float(this),other)*1e-10
	def __radd__(this,other):
		return frac.__add__(this,other)
	def __add__(this,other):
		if type(other)==int:
			return this+frac(other*this.d,this.d)
		elif type(other)==float:
			return float(this)+other
		new_denom=lcm(this.d,other.d)
		new_numer=this.n*new_denom//this.d + other.n*new_denom//other.d
		return frac(new_numer,new_denom).reduce()
	def __rmul__(this,other):
		return frac.__mul__(this,other)
	def __mul__(this,other):
		if type(other) == int:
			return frac(this.n*other,this.d).reduce()
		elif type(other)==float:
			return float(this)*other
		return frac(this.n*other.n,this.d*other.d).reduce()
	def __truediv__(this,other): #Defines how the "/" operator works
		if type(other) ==int:
			return frac(this.n,this.d*other).reduce()
		elif type(other) == float:
			return float(this)/other
		else:
			return (this*frac(other.d,other.n)).reduce()
	def __rtruediv__(this,other):
		return frac.__mul__(frac(this.d,this.n),other)
	def reduce(this):
		return frac(this.n//math.gcd(this.n,this.d),this.d//math.gcd(this.n,this.d))
	def __sub__(this,other):
		return this + other*(-1)
	def __rsub__(this,other):
		return other+(this*-1)
	def __pow__(this,other): #Defines how the ** operator works
		if type(other)==int:
			return frac(this.n**other,this.d**other)
		else:
			return float(this)**float(other)
	def __str__(this):
		return str(this.n)+"/"+str(this.d)
	def __repr__(this):
		return "frac({0},{1})".format(this.n,this.d)
	def copy(this):
		return frac(this.n,this.d)
	def __float__(this):
		return this.n/this.d
	def __int__(this):
		return int(this.n/this.d)
	def __round__(self,precision=None):
		return self
	def __neg__(this):
		return this*-1
	def __gt__(this,other):
		return this!=other and float(other)<float(this)
	def __lt__(this,other):
		return this!=other and float(other)>float(this)
	def __ge__(this,other):
		return this==other or this>other
	def __le__(this,other):
		return this==other or this<other
	def __hash__(this):
		return hash(str(this))
		
class polynom(object):
	'''Create an object that represents a polynomial, which can be called with arg x to evaluate the polynomial at x.
Has convenient functions for integration, differentiation, and addition and multiplication with other polynomials and
	with scalars.
Examples:
Let quad = polynom([-4,1,2])
quad(3) = -4*3**2 + 1*3 + 2 = -31
quad.der() = polynom([-8,1]) #d/dx of quad
quad.Int() = polynom([-4/3,1/2,2,0]) the indefinite integral of quad
quad**2 = polynom([16, -8, -15, 4, 4])
quad+quad/2 = polynom([-6.0, 1.5, 3.0])
quad.Int(1,7) = -420 #The integral of quad from 1 to 7
quad.Int(1) = polynom([-1.3333333333333333, 0.5, 2.0, -1.16666666667]) #The indefinite integral of quad from 1 to x.
	'''
	def __init__(self,args):
		self.args=list(args)
	def __call__(self,x):
		return sum(self[i]*x**(len(self)-i-1) for i in range(len(self)))
	def __getitem__(self,tup):
		return self.args[tup]
	def __str__(self):
		Doc=""
		for i in range(len(self)-1):
			if self[i]!=0:
				Doc+=str(round(self[i],7))+'*x**'+str(len(self)-i-1)+" + "
		Doc+=str(self[-1])
		return Doc
	def __repr__(self):
		return "polynom("+str(self.args)+")"
	def __len__(self):
		return len(self.args)
	def Int(self,start=None,end=None):
		'''Default: return the indefinite integral of this polynomial.
If start is a number and end is None: return the indefinite integral of this polynomial 
	minus this polynomial evaluated at start.
If start and end are both numbers: return the integral of this function from start to end.
		'''
		new = polynom([self.args[i]/(len(self)-i) for i in range(len(self))]+[0])
		if end is None:
			if start is None:
				return new
			else:
				return new-new(start)
		else:
			return new(end)-new(start)
	def der(self,x=None):
		'''Default: return the function d/dx (this polynomial)
If x is not None: return this function's derivative evaluated at x.'''
		if len(self)==1:
			return 0
		out=polynom([self.args[i]*(len(self)-i-1) for i in range(len(self)-1)])
		if x is None:
			return out
		return out(x)
	def __add__(self,other):
		if type(other) in [int,float,frac]:
			return polynom(self.args[:-1]+[other+self.args[-1]])
		if type(other)==polynom:
			newargs=[]
			if len(other)>len(self):
				longer,shorter = other.args,self.args
			else:
				longer, shorter = self.args, other.args
			shorter=[0 for i in range(len(longer)-len(shorter))]+shorter
			for i in range(len(longer)):
				try:
					newargs.append(shorter[i]+longer[i])
				except:
					newargs.append(longer[i])
		return polynom(newargs)
	def __radd__(this,other):
		return polynom.__add__(this,other)
	def __sub__(self,other):
		return self + other*-1
	def __rsub__(self,other):
		return self*-1+other
	def __neg__(self):
		return polynom([-i for i in self.args])
	def sum(polynom_list):
		'''Adds together all polynomials in a list or tuple of polynom objects'''
		new=polynom_list[0]
		for i in range(1,len(polynom_list)):
			new+=polynom_list[i]
		return new
	def __rmul__(self,other):
		return self*other
	def __truediv__(self,other):
		return polynom([self[i]/other for i in range(len(self))])
	def __mul__(self,other):
		if type(other) in [int,float,frac]:
			return polynom([self.args[i]*other for i in range(len(self))])
		elif type(other)==polynom:
			new=[0 for i in range(len(self)+len(other)-1)]
			for i in range(len(other)):
				for z in range(len(self)):
					new[i+z]+=other[i]*self[z]
		return polynom(new)
	def __pow__(self,n):
		assert n>=1 and int(n)==n, "Can't raise polynom object to a power that's not a positive integer!"
		new=polynom(self.args)
		for i in range(n-1):
			new*=self
		return new
	
	def __eq__(self,other):
		if type(other) in [int,float] and len(self)==1:
			return self[0]==other #a polynomial of degree 1 is just a scalar
		elif isinstance(other,polynom):
			return self.args==other.args
	def __float__(self):
		if len(self)==1:
			return float(self[0])
		else:
			raise TypeError("Polynomial of degree >1 not a valid arg for float()")
	def __int__(self):
		if len(self)==1:
			return int(self[0])
		else:
			raise TypeError("Polynomial of degree >1 not a valid arg for int()")
	def zeros(self):
		'''Find zeros of the function.'''
		if len(self)==2:
			try:
				return -self[0]/self[1]
			except ZeroDivisionError:
				return "First degree polynomial has no roots."
		if len(self)==3:
			return quadroot(self[0],self[1],self[2])

quartic = polynom([5,1,-1,0,2.3423])
iquart=quartic.Int()
dquart=quartic.der()

exp=lambda x: e**x

tan = lambda x: np.sin(x)/np.cos(x)
sec2 = lambda x: 1/(np.cos(x))**2
itan = lambda x: -np.log(abs(cos(x)))

ilog= lambda x: x*np.log(x) - x

trigo = lambda x: np.cos(x) + 3*x* e**(-x**2 +4)
dtrigo=lambda x: -np.sin(x) + 3*e**(-x**2+4) -6*x**2 * e**(-x**2+4)
itrigo = lambda x: -1.5 * e**(-x**2 + 4)

test_funcs = {'exp': exp, 'log': np.log, 'tan':tan, 'trig':trigo,'quar':quartic,'exp_pdf':exp_pdf}

test_derivs={'dexp':exp,'dlog':lambda x:1/x, 'dtan':lambda x: sec2, 'dtrig': dtrigo, 'dquar':dquart,'dexp_pdf':lambda x,l: -l**2 * e**(-x*l)}

test_integrals={'iexp':exp,'ilog':ilog,'itan': itan, 'itrig':itrigo, 'iquar': iquart, 'iexp_pdf': exp_cdf}


def ct10(num):
	'''Return a tuple (num_ones,num_zeros) in the binary representation of num.'''
	out=[0,0]
	while num>0:
		out[1-num&1]+=1
		num>>=1
	return out
